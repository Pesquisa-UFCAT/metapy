---
title: Mutation 01 Movement
layout: home
grand_parent: Framework
parent: Common Library
has_children: true
nav_order: 7
---

<!--Don't delete ths script-->
<script src = "https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id = "MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<!--Don't delete ths script-->
<!--
MUTATION_01_MOVEMENT
{: .label .label-green }
-->

```python
xII, ofINew, fitINew, neof = MUTATION_01_MOVEMENT(OF_FUNCTION, xI, xL, xU, d, pdf, sigma, NULL_DIC = 1)
```

<p align = "justify">This function mutates a solution using a Gaussian or Uniform distribution.</p>

Input variables
{: .label .label-yellow }

<table style = "width:100%">
    <thead>
      <tr>
        <th>Name</th>
        <th>Description</th>
        <th>Type</th>
      </tr>
    </thead>
    <tr>
        <td><code>OF_FUNCTION</code></td>
        <td>Objective function to be optimized</td>
        <td>Py function (<code>def</code>)</td>
    </tr>
    <tr>
        <td><code>X_I_OLD</code></td>
        <td>List containing the values of the current solution</td>
        <td>Py list [D]</td>
    </tr>
    <tr>
        <td><code>X_L</code></td>
        <td>List containing the lower limits for each decision variable</td>
        <td>Py list [D]</td>
    </tr>
    <tr>
        <td><code>X_U</code></td>
        <td>List containing the upper limits for each decision variable</td>
        <td>Py list [D]</td>
    </tr>
    <tr>
        <td><code>D</code></td>
        <td>Problem dimension</td>
        <td>Integer</td>
    </tr>
    <tr>
        <td><code>PDF</code></td>
        <td>Probability Density Function select</td>
        <td>string</td>
    </tr>
    <tr>
        <td><code>SIGMA</code></td>
        <td>Control parameter for the Gaussian or Uniform distribution in percentage. In Gaussian or Uniform distribution, \(\sigma\) equivalent to a standard deviation</td>
        <td>float</td>
    </tr>
    <tr>
        <td><code>SEED</code></td>
        <td>Optional. Seed for generating random numbers. Default <code>SEED = None</code></td>
        <td>Null or integer</td>
    </tr>
    <tr>
        <td><code>NULL_DIC</code></td>
        <td>Variable to use some external data you want in the objective function. When you use NULL_DIC, your data is already saved in memory. Default <code>NULL_DIC = None</code></td>
        <td>Py dict or None</td>
    </tr>
</table>

Output variables
{: .label .label-yellow }

<table style = "width:100%">
    <thead>
      <tr>
        <th>Name</th>
        <th>Description</th>
        <th>Type</th>
      </tr>
    </thead>
    <tr>
        <td><code>X_I_NEW</code></td>
        <td>New solution generated by the mutation, containing the values of the decision variables after applying the Gaussian or Uniform distribution and checking the limits</td>
        <td>Py list [D]</td>
    </tr>
    <tr>
        <td><code>OF_I_NEW</code></td>
        <td>Value of the objective function associated with the new solution <code>X_I_NEW</code></td>
        <td>float</td>
    </tr>
    <tr>
        <td><code>FIT_I_NEW</code></td>
        <td>Fitness value associated with the new solution after applying an adjustment function to the objective function value</td>
        <td>float</td>
    </tr>
    <tr>
        <td><code>NEOF</code></td>
        <td>New solution indicator. It is a Boolean value (1 to indicate a new solution)</td>
        <td>int</td>
    </tr>
</table>

Theory
{: .label .label-red }

<p align = "justify">
    See Hill Climbing Theory.
</p>

Example 6
{: .label .label-blue }

<p align = "justify">
  <i>
    Use the <code>MUTATION_01_MOVEMENT</code> function to generate a new solution from an existing solution, applying a standard deviation 15% in current design variables. Use the range \(\mathbf{x}_L = [1.0, 1.0, 1.0]\) and \(\mathbf{x}_L = [3.0, 3.0, 3.0]\). Consider current solution \(\mathbf{x}_i = [2.0, 2.0, 2.0]\).
  </i>
</p>

```python
# Data
xL = [1, 1, 1]
xU = [3, 3, 3]
d = len(xL)
sigma = 15 / 100 # 15%
xI = [2, 2, 2]
pdf = 'UNIFORM'

# Objective function
def OF_FUNCTION(X, NULL_DIC):
    x0 = X[0]
    x1 = X[1]
    x2 = X[2]
    of = x0 ** 2 + x1 ** 2 + x2 ** 2
    return of

# Call function
xII, ofINew, fitINew, neof = MUTATION_01_MOVEMENT(OF_FUNCTION, xI, xL, xU, d, pdf, sigma, NULL_DIC = 1)

# Output details
print('x New: ', xII)
print('of New: ',ofINew)
print('fit New: ', fitINew)
print('number of evalutions objective function: ',neof)
```

```bash
x New:  [2.0532085664365676, 2.0237328790140405, 2.2571792918690035]
of New:  13.406018538533218
fit New:  0.06941543198248705
number of evalutions objective function:  1
```
