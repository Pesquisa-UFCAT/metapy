---
layout: default
title: mutation_01_movement
grand_parent: Framework
parent: Common Library
has_toc: false
nav_order: 7
---

<!--Don't delete ths script-->
<script src = "https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id = "MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<!--Don't delete ths script-->

```python
xII, ofINew, fitINew, neof = mutation_01_movement(OF_FUNCTION, xI, xL, xU, d, pdf, sigma, null_dic = 1)
```

<p align = "justify">This function mutates a solution using a Gaussian or Uniform distribution.</p>

Input variables
{: .label .label-yellow }

<table style = "width:100%">
    <thead>
      <tr>
        <th>Name</th>
        <th>Description</th>
        <th>Type</th>
      </tr>
    </thead>
    <tr>
        <td><code>of_function</code></td>
        <td>Objective function to be optimized</td>
        <td>Py function (<code>def</code>)</td>
    </tr>
    <tr>
        <td><code>x_i_old</code></td>
        <td>List containing the values of the current solution</td>
        <td>Py list [D]</td>
    </tr>
    <tr>
        <td><code>x_l</code></td>
        <td>List containing the lower limits for each decision variable</td>
        <td>Py list [D]</td>
    </tr>
    <tr>
        <td><code>x_u</code></td>
        <td>List containing the upper limits for each decision variable</td>
        <td>Py list [D]</td>
    </tr>
    <tr>
        <td><code>d</code></td>
        <td>Problem dimension</td>
        <td>Integer</td>
    </tr>
    <tr>
        <td><code>pdf</code></td>
        <td>Probability Density Function select</td>
        <td>string</td>
    </tr>
    <tr>
        <td><code>sigma</code></td>
        <td>Control parameter for the Gaussian or Uniform distribution in percentage. In Gaussian or Uniform distribution, \(\sigma\) equivalent to a standard deviation</td>
        <td>float</td>
    </tr>
    <tr>
        <td><code>seed</code></td>
        <td>Optional. Seed for generating random numbers. Default <code>seed = None</code></td>
        <td>Null or integer</td>
    </tr>
    <tr>
        <td><code>null_dic</code></td>
        <td>Variable to use some external data you want in the objective function. When you use <code>null_dic</code>, your data is already saved in memory. Default <code>null_dic = None</code></td>
        <td>Py dict or None</td>
    </tr>
</table>

Output variables
{: .label .label-yellow }

<table style = "width:100%">
    <thead>
      <tr>
        <th>Name</th>
        <th>Description</th>
        <th>Type</th>
      </tr>
    </thead>
    <tr>
        <td><code>x_i_new</code></td>
        <td>New solution generated by the mutation, containing the values of the decision variables after applying the Gaussian or Uniform distribution and checking the limits</td>
        <td>Py list [D]</td>
    </tr>
    <tr>
        <td><code>of_i_new</code></td>
        <td>Value of the objective function associated with the new solution <code>X_I_NEW</code></td>
        <td>float</td>
    </tr>
    <tr>
        <td><code>fit_i_new</code></td>
        <td>Fitness value associated with the new solution after applying an adjustment function to the objective function value</td>
        <td>float</td>
    </tr>
    <tr>
        <td><code>neof</code></td>
        <td>New solution indicator. It is a Boolean value (1 to indicate a new solution)</td>
        <td>int</td>
    </tr>
</table>

Theory
{: .label .label-red }

<p align = "justify">
    See Hill Climbing Theory.
</p>

Example 6
{: .label .label-blue }

<p align = "justify">
  <i>
    Use the <code>mutation_01_movement</code> function to generate a new solution from an existing solution, applying a standard deviation 15% in current design variables. Use the range \(\mathbf{x}_L = [1.0, 1.0, 1.0]\) and \(\mathbf{x}_L = [3.0, 3.0, 3.0]\). Consider current solution \(\mathbf{x}_i = [2.0, 2.0, 2.0]\).
  </i>
</p>

```python
# Data
xL = [1, 1, 1]
xU = [3, 3, 3]
d = len(xL)
sigma = 15 / 100 # 15%
xI = [2, 2, 2]
pdf = 'UNIFORM'

# Objective function
def OF_FUNCTION(X, NULL_DIC):
    x0 = X[0]
    x1 = X[1]
    x2 = X[2]
    of = x0 ** 2 + x1 ** 2 + x2 ** 2
    return of

# Call function
xII, ofINew, fitINew, neof = mutation_01_movement(OF_FUNCTION, xI, xL, xU, d, pdf, sigma, null_dic = 1)

# Output details
print('x New: ', xII)
print('of New: ',ofINew)
print('fit New: ', fitINew)
print('number of evalutions objective function: ',neof)
```

```bash
x New:  [2.0532085664365676, 2.0237328790140405, 2.2571792918690035]
of New:  13.406018538533218
fit New:  0.06941543198248705
number of evalutions objective function:  1
```
